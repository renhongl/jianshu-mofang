{
    "_id": 0.5766040727727896,
    "title": "数据结构算法 - 红黑树",
    "author": "红橙Darren",
    "time": "2018.10.21 17:38*",
    "words": "字数 1967",
    "views": "阅读 990",
    "comments": "评论 2",
    "likes": "喜欢 44",
    "content": "红黑树是一棵自平衡的二叉搜索树，因此在学习红黑树之前，我们需要回顾一下之前所学的知识二叉搜索树和平衡二叉树。\n1.二叉搜索树\n二叉搜索树又叫二叉查找树或者二叉排序树，它首先是一个二叉树，而且必须满足下面的条件：\n1）若左子树不空，则左子树上所有结点的值均小于它的根节点的值；\n2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值\n3）左、右子树也分别为二叉搜索树\n\n二叉搜索树示例\n2.平衡二叉树\n二叉搜索树解决了许多问题，比如可以快速的查找最大值和最小值，可以快速找到排名第几位的值，快速搜索和排序等等。但普通的二叉搜索树有可能出现极不平衡的情况（斜树），这样我们的时间复杂度就有可能退化成 O(N) 的情况。比如我们现在插入的数据是 [1,2,3,4,5,6,7] 转换为二叉树如下：\n斜树\n由于普通的二叉搜索树会出现极不平衡的情况，那么我们就必须得想想办法了，这个时候平衡二叉树就能帮到我们了。什么是平衡二叉树？平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n平衡二叉树有一个很重要的性质：左右两个子树的高度差的绝对值不超过1。那么解决方案就是如果二叉树的左右高度超过 1 ，我们就把当前树调整为一棵平衡二叉树。这就涉及到左旋、右旋、先右旋再左旋、先左旋再右旋。\n2.1 右旋：\n右旋.png\n   TreeNode<K, V> *R_Rotation(TreeNode<K, V> *pNode) {\n        TreeNode<K, V> *left = pNode->left;\n        TreeNode<K, V> *right = left->right;\n        left->right = pNode;\n        pNode->left = right;\n        // 重新调整高度\n        pNode->height = max(getHeight(pNode->left), getHeight(pNode->right)) + 1;\n        left->height = max(getHeight(left->left), getHeight(left->right)) + 1;\n        return left;\n    }\n2.2 左旋：\n左旋\n  TreeNode<K, V> *L_Rotation(TreeNode<K, V> *pNode) {\n        TreeNode<K, V> *right = pNode->right;\n        TreeNode<K, V> *left = right->left;\n        right->left = pNode;\n        pNode->right = left;\n        // 重新调整高度\n        pNode->height = max(getHeight(pNode->left), getHeight(pNode->right)) + 1;\n        right->height = max(getHeight(right->left), getHeight(right->right)) + 1;\n        return right;\n    }\n2.3 先右旋再左旋：\n先右旋再左旋\n  TreeNode<K, V> *R_L_Rotation(TreeNode<K, V> *pNode) {\n    pNode->right = R_Rotation(pNode->right);\n    return L_Rotation(pNode);\n  }\n2.4 先左旋再右旋：\n先左旋再右旋\n  TreeNode<K, V> *L_R_Rotation(TreeNode<K, V> *pNode) {\n    pNode->left = L_Rotation(pNode->left);\n    return R_Rotation(pNode);\n  }\n2.红黑树\n红黑树用法就比较广了，比如 JDK 1.8 的 HashMap，TreeMap，C++ 中的 map 和 multimap 等等。红黑树学习起来还是有一点难度的，这时如果我们心中有 B 树就有助于理解它，如果没有 B 树也没有关系。\n红黑树的特性:\n（1）每个节点或者是黑色，或者是红色。\n（2）根节点是黑色。\n（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n（4）如果一个节点是红色的，则它的子节点必须是黑色的。\n（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。\n\n红黑树\n假设我们现在要插入一个新的节点，如过插入的这个新的节点为黑色，那么必然会违反性质(5)，所以我们把新插入的点定义为红色的。但是如果插入的新节点为红色，就可以能会违反性质(4) ，因此我们需要对其进行调整，使得整棵树依然满足红黑树的性质，也就是双红修正。接下来我们只要分情况分析就可以了：\n如果没有出现双红现象，父亲是黑色的不需要修正；\n叔叔是红色的 ，将叔叔和父亲染黑，然后爷爷染红；\n叔叔是黑色的，父亲是爷爷的左节点，且当前节点是其父节点的右孩子，将“父节点”作为“新的当前节点”，以“新的当前节点”为支点进行左旋。然后将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行右旋；\n叔叔是黑色的，父亲是爷爷的左节点，且当前节点是其父节点的左孩子，将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行右旋；\n叔叔是黑色的，父亲是爷爷的右节点，且当前节点是其父节点的左孩子，将“父节点”作为“新的当前节点”，以“新的当前节点”为支点进行右旋。然后将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行左旋；\n叔叔是黑色的，父亲是爷爷的右节点，且当前节点是其父节点的右孩子，将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行左旋；\n上面的双红修正现象看似比较复杂，但实际上只有三种情况，一种是没有双红现象，另一种是父亲和叔叔都是红色的，最后一种是叔叔是黑色的。我们来画个实例看下：\n\nvoid solveDoubleRed(TreeNode *pNode) {\n        while (pNode->parent && pNode->parent->color == red) {// 情况 1\n            TreeNode *uncle = brother(parent(pNode));\n\n            if (getColor(uncle) == red) {// 情况2\n                // 设置双亲和叔叔为黑色\n                setColor(parent(pNode), black);\n                setColor(uncle, black);\n                // 指针回溯至爷爷\n                pNode = parent(parent(pNode));\n            } else {\n                // 父亲是爷爷的左儿子\n                if (parent(parent(pNode))->left = parent(pNode)) { // 情况 3 和 4\n                    // 自己是父亲的右儿子\n                    if (parent(pNode)->right == pNode) {\n                        pNode = parent(pNode);\n                        L_Rotation(pNode);\n                    }\n                    // 把我自己这边的红色节点挪到隔壁树上，但仍然不能违反性质 4 和 5\n                    setColor(parent(pNode), black);\n                    setColor(parent(parent(pNode)), red);\n                    R_Rotation(parent(parent(pNode)));\n                } else { // 情况 5 和 6\n                    // 自己是父亲的左儿子\n                    if (parent(pNode)->left == pNode) {\n                        pNode = parent(pNode);\n                        R_Rotation(pNode);\n                    }\n                    // 把我自己这边的红色节点挪到隔壁树上，但仍然不能违反性质 4 和 5\n                    setColor(parent(pNode), black);\n                    setColor(parent(parent(pNode)), red);\n                    L_Rotation(parent(parent(pNode)));\n                }\n            }\n        }\n\n        // 根结点为黑色\n        root->color = black;\n    }\n哎～好复杂这怎么记得住。如果要记住肯定不太可能而且费劲，接下来我们来分析下为什么要这么操作，还有没有更好的调整方法。我们所有的调整都是为了不违反性质4和性质5，假设我在左边的这个支树上新增了一个红色的节点，违反了性质4 。想法就是我把左支树上的一个红色节点，挪动右支树上去，这样就解决了我有两个连续红色节点的问题。但挪给右支树的过程中不能违反性质4和性质5，所以必须得考虑叔叔节点的颜色。\n最后我们来看下红黑树的删除操作，红黑树的删除操作要比新增操作要复杂些，但总体来说都是出现问题就去解决问题。当我们移除的是一个红色节点，那么根本就不会影响我们的性质4和性质5，我们不需要调整，但倘若我们移除的是一个黑色的节点，这时肯定会违反我们的性质5，所以我们只需要调整移除黑色节点的情况。分情况讨论下：\n如果兄弟节点是红色的，把兄弟节点染黑，父节点染红，左/右旋父节点；\n如果兄弟节点是黑色的，并且两个侄子节点都是黑色的，将兄弟节点染红，指针回溯至父亲节点；\n如果兄弟节点是黑色，的并且远侄子是黑色的，近侄子是红色的，将进侄子染黑，兄弟染红，左/右旋兄弟节点，进入下面情况 4 ；\n如果兄弟节点是黑色的，并且远侄子是红色的，近侄子随意，将兄弟节点染成父亲节点的颜色，父亲节点染黑，远侄子染黑，左/右旋父亲节点。\n\nvoid solveLostBlack(TreeNode *pNode) {\n        while (pNode != root && getColor(pNode) == black) {\n            if (left(parent(pNode)) == pNode) {\n                TreeNode *sib = brother(pNode);\n                if (getColor(sib) == red) {\n                    setColor(sib, black);\n                    setColor(parent(pNode), red);\n                    L_Rotation(parent(pNode));\n                    sib = brother(pNode);\n                }\n\n                if (getColor(left(sib)) == black && getColor(right(sib)) == black) {\n                    setColor(sib, red);\n                    pNode = parent(pNode);\n                } else {\n                    if (getColor(right(sib)) == black) {\n                        setColor(left(sib), black);\n                        setColor(sib, red);\n                        R_Rotation(sib);\n                        sib = brother(pNode);\n                    }\n\n                    setColor(sib, getColor(parent(pNode)));\n                    setColor(parent(pNode), black);\n                    setColor(right(sib), black);\n                    L_Rotation(parent(pNode));\n                    pNode = root;\n                }\n            } else {\n                TreeNode *sib = brother(pNode);\n                if (getColor(sib) == red) {\n                    setColor(sib, black);\n                    setColor(parent(pNode), red);\n                    R_Rotation(parent(pNode));\n                    sib = brother(pNode);\n                }\n\n                if (getColor(left(sib)) == black && getColor(right(sib)) == black) {\n                    setColor(sib, red);\n                    pNode = parent(pNode);\n                } else {\n                    if (getColor(left(sib)) == black) {\n                        setColor(right(sib), black);\n                        setColor(sib, red);\n                        L_Rotation(sib);\n                        sib = brother(pNode);\n                    }\n\n                    setColor(sib, getColor(parent(pNode)));\n                    setColor(parent(pNode), black);\n                    setColor(left(sib), black);\n                    R_Rotation(parent(pNode));\n                    pNode = root;\n                }\n            }\n        }\n        pNode->color = black;\n    }\n视频链接:https://pan.baidu.com/s/1Z93XZ4_vntWXgofF2YRiAA\n视频密码:8t2m"
}