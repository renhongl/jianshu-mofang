{
    "_id": 0.8361353782965141,
    "title": "AOP实现Android集中式登陆架构",
    "author": "xiasem",
    "time": "2018.08.16 15:33*",
    "words": "字数 2832",
    "views": "阅读 401",
    "comments": "评论 0",
    "likes": "喜欢 18",
    "content": "未经同意禁止抄袭，如需转载请在显要位置标注\n前言\n登陆应该是应用开发中一个很常见的功能，一般在应用中有两种登陆，一种是一进入应用就必须登陆才能使用（如微信和QQ等），另一种是需要登录的时候才会去登陆（如淘宝京东等）。我在工作中遇到的大部分是第二种情况，针对于第二种的登陆，我之前都是通过if(){}else()去判断是否登录的，但是这样项目结构庞大了之后就会使代码臃肿。因为判断用户登陆状态是一个频次很高的操作，所以针对这方面我就考虑有没有一种方案既能很方便的判断登陆状态又使代码很简洁。\n想来想去方案有两种，一种是hook到AMS拦截startActivity中的intent，在启动activity的时候判断是否登录，如果没有对intent做动态替换，另一种就是通过AOP实现方法添加判断登陆代码片段。hook对系统有兼容性，需要考虑到各个版本的api是否改动，而aop的实现方式与版本没有任何兼容性问题，所以最后就采用了aop的方式去实现app集中式登陆。\n集中式登陆架构的使用\n为什么我先讲架构的使用，是因为你只有知道了使用这种架构是多么方便，才会有兴趣去了解如何实现这种架构。下面看代码：\n\n我们在Application里进行初始化(初始化之后才能接收登陆事件，所以越早越好)。\npublic class MyApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        LoginSDK.getInstance().init(this, new ILogin() {\n            @Override\n            public void login(Context applicationContext, int userDefine) {\n                switch (userDefine) {\n                    case 0:\n                        startActivity(new Intent(applicationContext, LoginActivity.class));\n                        break;\n                    case 1:\n                        Toast.makeText(applicationContext, \"您还没有登录，请登陆后执行\", Toast.LENGTH_SHORT).show();\n                        break;\n                    case 2:\n                        new AlertDialog.Builder(MyApplication.this)...\n                        break;\n                    default:\n                        Toast.makeText(applicationContext, \"执行失败，因为您还没有登录！\", Toast.LENGTH_SHORT).show();\n                        break;\n                }\n            }\n\n            @Override\n            public boolean isLogin(Context applicationContext) {\n                return SharePreferenceUtil.getBooleanSp(SharePreferenceUtil.IS_LOGIN, applicationContext);\n            }\n        });\n    }\n  }\n可以看到初始化方法实现了ILogin接口，ILogin接口有两个方法，第一个login()用于接收登陆事件，第二个方法isLogin是判断登陆状态，这两个方法留给用户自己实现，提高架构的可用性。我们所有的登陆请求都会回调到ILogin接口，这也意味着登陆事件只有一个统一的入口，这也就是我们集中式登陆架构的核心好处了。\n好了，我们先来使用以下。\n例子1：\n@LoginFilter(userDefine = 0)\npublic void skip(View view) {\n    startActivity(new Intent(this, SecondActivity.class));\n}\n上面代码就是监听一个Button的点击事件，然后加入注解@LoginFilter，看方法实现只是跳转到SecondActivity，并没有登陆逻辑的判断，但通过这个注解我们就可以在运行时检测是否登录，如果没有登录就会中断方法的执行，转而调用MyApplication里init()方法中我们自己实现的login()方法，login(Context applicationContext, int userDefine)方法中userDefine是留给用户自定义的一个值，为了区别使用哪种登录方式。是不是很简单？再来看例子二：\n例子2：\n如果我们嫌弃在需要判断登陆状态的按钮上加入@LoginFilter()注解麻烦，而是想实现启动一个Activity自动判断是否登录，如果没有登录就回调到我们的ILogin接口，那么你只需要创建一个LoginFilterActivity如下：\npublic class LoginFilterActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (lib_login_filter_onCreate(true)) {\n            //TOOD： 你可以做想做的逻辑，如跳转到登录界面或给用户提示\n            finish();\n        }\n    }\n\n    @LoginFilter\n    public Boolean lib_login_filter_onCreate(Boolean aspectParam) { return aspectParam; }\n}\n然后我们让需要登陆才能进入的Activity继承自LoginFilterActivity就可以了。假如UserActivity继承了LoginFilterActivity，当用户没有登陆的时候，我们启动UserActivity的时候便会回调到我们的ILogin接口，是不是很方便，这就是我们今天要讲的集中式登陆架构。\n下面，我们来讲一讲如何实现这个架构。\nAOP原理\n我们先来了解一下AOP，因为这个架构是基于AOP编程实现的。\n什么是AOP\n关于AOP是什么，这里我简单介绍一下，AOP是Aspect Oriented Programming的缩写，即面向切面编程，与面向对象编程(oop)是两种不同的思维方式，也可以看做是对oop的一种补充。传统的oop开发会提倡功能模块化等，而aop适合于针对某一类型的问题统一处理。AOP思想的讲解不是我们本篇文章的重点，如果有同学对AOP思想不是很理解，这里我推荐一篇文章，讲得很不错Java AOP & Spring AOP 原理和实现\nAspectJ介绍\nAspectJ是一个面向切面编程的一个框架，它扩展了java语言，并定义了实现AOP的语法。我们知道，在将.java文件编译为.class文件时默认使用javac编译工具，而AspectJ会有一套符合java字节码编码规范的编译工具来替代javac，在将.java文件编译为.class文件时，会动态的插入一些代码来做到对某一类特定东西的统一处理。我举个例子，比如在应用中有很多个button的onClick事件需要检测是否登录，如果没有登录则需要去登陆之后才能继续执行，针对这一类型的问题，相对笨一点的做法就是在每一个onClick方法中都显式的去判断登陆状态，这样不免过于麻烦。而我们用AOP的方式实现的话，就需要在每一个onClick方法上加入一个标注，让编译器在编译时能识别到这个标注，然后根据标注来生成一些代码检测登录状态。好了，如果有同学对AOP还不是很理解的话也不用急，下面我会用例子来给大家演示如何使用AOP实现统一的集中式登陆。\nAOP实现集中式登陆\naspectj环境搭建\n首先，我们导入AspectJ的jar包，AspectJ的jar网上一搜就有，也可以直接去我demo里面拿，LoginArchitecture AOP实现集中式登陆 github链接点我。demo里jar包导入：\n<img src=\"https://user-gold-cdn.xitu.io/2018/8/16/1654195c6dc3a787?w=433&h=134&f=jpeg&s=6306\" />\n\n好了，导入jar后还需要在app.gradle配置如下：\nbuildscript {\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath 'org.aspectj:aspectjtools:1.8.8'\n        classpath 'org.aspectj:aspectjweaver:1.8.8'\n    }\n}\n然后在文件末尾添加如下代码：\nimport org.aspectj.bridge.IMessage\nimport org.aspectj.bridge.MessageHandler\nimport org.aspectj.tools.ajc.Main\n\nfinal def log = project.logger\nfinal def variants = project.android.applicationVariants\n\nvariants.all { variant ->\n    if (!variant.buildType.isDebuggable()) {\n        log.debug(\"Skipping non-debuggable build type '${variant.buildType.name}'.\")\n        return;\n    }\n\n    JavaCompile javaCompile = variant.javaCompile\n    javaCompile.doLast {\n        String[] args = [\"-showWeaveInfo\",\n                         \"-1.8\",\n                         \"-inpath\", javaCompile.destinationDir.toString(),\n                         \"-aspectpath\", javaCompile.classpath.asPath,\n                         \"-d\", javaCompile.destinationDir.toString(),\n                         \"-classpath\", javaCompile.classpath.asPath,\n                         \"-bootclasspath\", project.android.bootClasspath.join(File.pathSeparator)]\n        log.debug \"ajc args: \" + Arrays.toString(args)\n\n        MessageHandler handler = new MessageHandler(true);\n        new Main().run(args, handler);\n        for (IMessage message : handler.getMessages(null, true)) {\n            switch (message.getKind()) {\n                case IMessage.ABORT:\n                case IMessage.ERROR:\n                case IMessage.FAIL:\n                    log.error message.message, message.thrown\n                    break;\n                case IMessage.WARNING:\n                    log.warn message.message, message.thrown\n                    break;\n                case IMessage.INFO:\n                    log.info message.message, message.thrown\n                    break;\n                case IMessage.DEBUG:\n                    log.debug message.message, message.thrown\n                    break;\n            }\n        }\n    }\n}\n这一大片代码就是为了在编译时打印信息如警告、error等等，这些东西在网上也有很多，不再一一解释。\n切面代码编写\n好了，配置完上面的内容之后，我们就开始编写代码了，首先，定义一个注解LoginFilter，用来注解方法，以便在编译期被编译器检测到需要做切面的方法。\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface LoginFilter {\n\n    int userDefine() default 0;\n\n}\n大家看到我在注解里加了个userDefine，就是为了给用户提供自定义实现，如根据userDifine值不同做不同的登陆处理。\n然后，编写LoginSDK文件用于初始化和接收登录事件，代码如下：\npublic class LoginSDK {\n\n  public void init(Context context, ILogin iLogin) {\n      applicationContext = context.getApplicationContext();\n      LoginAssistant.getInstance().setApplicationContext(context);\n      LoginAssistant.getInstance().setiLogin(iLogin);\n  }\n\n  //...\n\n}\n然后，新建LoginFilterAspect.java文件用来处理加入LoginFilter注解的方法，对这些方法做统一的切面处理。\n@Aspect\npublic class LoginFilterAspect {\n    private static final String TAG = \"LoginFilterAspect\";\n\n    @Pointcut(\"execution(@com.xsm.loginarchitecture.lib_login.annotation.LoginFilter * *(..))\")\n    public void loginFilter() {}\n\n    @Around(\"loginFilter()\")\n    public void aroundLoginPoint(ProceedingJoinPoint joinPoint) throws Throwable {\n        //标注1\n        ILogin iLogin = LoginAssistant.getInstance().getiLogin();\n        if (iLogin == null) {\n            throw new NoInitException(\"LoginSDK 没有初始化！\");\n        }\n\n        //标注2\n        Signature signature = joinPoint.getSignature();\n        if (!(signature instanceof MethodSignature)) {\n            throw new AnnotationException(\"LoginFilter 注解只能用于方法上\");\n        }\n        MethodSignature methodSignature = (MethodSignature) signature;\n        LoginFilter loginFilter = methodSignature.getMethod().getAnnotation(LoginFilter.class);\n        if (loginFilter == null) {\n            return;\n        }\n\n        Context param = LoginAssistant.getInstance().getApplicationContext();\n        //标注3\n        if (iLogin.isLogin(param)) {\n            joinPoint.proceed();\n        } else {\n            //标注4\n            Object target = joinPoint.getTarget();\n            Method method = target.getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());\n            String name = method.getName();\n            if (name.contains(\"lib_login_filter_onCreate\")) {\n                //标注5\n                Object[] args = joinPoint.getArgs();\n                if (args != null && args.length == 1 && (args[0] instanceof Boolean)) {\n                    joinPoint.proceed(new Object[] {true});\n                } else {\n                    iLogin.login(param, loginFilter.userDefine());\n                }\n            } else {\n                iLogin.login(param, loginFilter.userDefine());\n            }\n        }\n    }\n}\n代码并不多，我们来一一解释。首先看loginFilter方法，这个方法上加入@Pointcut注解，并指定了LoginFilter注解的路径，@Pointcut注解包括aroundLoginPoint()方法上的@Around注解等都是AspectJ定义的API。@Pointcut注解代表切入点，具体就是指哪些方法需要被执行\"AOP\"。execution()里指定了LoginFilter注解的路径，即加入LoginFilter注解的方法就是需要处理的切面。@Around注解表示这个方法执行时机的前后都可以做切面处理，常用到的还有@Before、@After等等。@Before即方法执行前做处理，@After反之。\n\n好了，aroundLoginPoint(ProceedingJoinPoint joinPoint)方法就是对切面的具体实现了，这里ProceedingJoinPoint参数意为环绕通知，这个类里面可以获取到方法的签名等各种信息。\n标注1\n首先看标注1处，我们先获取用户实现的ILogin类，如果没有调用init()设置初始化就抛出异常。\n标注2\n标注2处先得到方法的签名methodSignature，然后得到@LoginFilter注解，如果注解为空，就不再往下走。\n标注3\n然后看标注3，调用iLogin的isLogin()方法判断是否登陆，这个isLogin是留给使用者自己实现的，如果登陆，就会继续执行方法体调用方法直到完成，如果没有登录，执行标注4。\n标注4\n首先获取到方法的对象，通过对象获取到方法名，然后判断方法名是否是“lib_login_filter_onCreate”，如果不是，调用iLogin.login()方法，这个login()方法也是留给用户自己实现的，如果方法名是“lib_login_filter_onCreate”，那么久执行标注5。\n标注5\n我们还记得在LoginFilterActivity里面有如下方法：\npublic class LoginFilterActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (lib_login_filter_onCreate(true)) {\n            //TOOD： 你可以做想做的逻辑，如跳转到登录界面或给用户提示\n            finish();\n        }\n    }\n\n    @LoginFilter\n    public Boolean lib_login_filter_onCreate(Boolean aspectParam) { return aspectParam; }\n}\n这个lib_login_filter_onCreate方法参数是Boolean类型，并且直接把参数当作返回值返回。其实这个方法的调用就是在标注5处，判断方法名等于lib_login_filter_onCreate并且参数为Boolean类型的时候，会调用这个方法然后传入true。那么为何要这么做呢？是因为当我们在继承LoginFilterActivity的时候，需要自动检测是否登陆，如果没有登录就finish()掉启动的Activity，所以你也就知道了，这个lib_login_filter_onCreate(Boolean aspectParam)方法是不能随便乱改的，如果需要进行修改，也要同时对LoginFilterAspect进行修改。\n\n好了，切面代码的处理介绍完了，这个时候我们build一下项目，会在项目下\\build\\intermediates\\classes\\debug文件夹生成经过AspectJ编译器编译后的.class文件，我们看下上面例子1中的方法skip(View v)方法，编译成class文件的方法体变成了如下这样：\n    @LoginFilter\n    public void skip(View view) {\n        JoinPoint var3 = Factory.makeJP(ajc$tjp_0, this, this, view);\n        skip_aroundBody1$advice(this, view, var3, LoginFilterAspect.aspectOf(), (ProceedingJoinPoint)var3);\n    }\n可以看到我们的点击事件方法已经被植入了一些代码，而原来startActivity(new Intent(this, SecondActivity.class));也不见了，实际上这里是把我们方法的执行给封装了，这里会在运行期，目标类加载后，为接口动态生成代理类，将切面织入到代理类中，从而实现对方法进行统一的处理。\n小结\n到这里，是不是觉得通过切面处理登陆很简单，实际上我们只要熟悉了切面编程的API，便可以利用这么简单的方法对一批拥有某项特征的东西做特定处理。本项目的demo我放在了github，如果对本篇文章感兴趣的同学可以clone下来自己熟悉之后，运用到项目中。demo地址，欢迎star，我的github还有许多有意思的库，欢迎参观哦\n联系方式：\nxiasem@163.com"
}